# Qt Demo Example

Demonstrates Qt-style programming patterns in ForGE, including signals/slots, UI files, resources, and translations.

## Overview

This example shows how to build Qt-style applications in ForGE with:
- QObject-based classes with signals and slots
- UI file compilation (.ui files)
- Resource management (.qrc files)
- Translation support (.ts files)
- Qt-style naming conventions and patterns

## Code

```fortran
!> @brief Qt-style demo application showcasing ForGE Qt tooling
!> @details Demonstrates signals/slots, resources, UI compilation, and translations
!> @author ForGE Contributors
!> @date 2025

program qt_demo
    use forge_qobject
    use forge_widgets
    use forge_app
    use forge_signals
    implicit none

    type(forge_application) :: app
    type(main_window) :: window

    ! Initialize application
    call app%init()
    call app%set_application_name("Qt Demo")
    call app%set_application_version("1.0.0")

    ! Create main window
    call window%init()
    call window%set_window_title("ForGE Qt Demo")
    call window%resize(600, 400)

    ! Setup UI (would be generated by uic in real usage)
    call window%setup_ui()

    ! Show window
    call window%show()

    ! Run application event loop
    call app%exec()

end program qt_demo

!> @brief Main window with Qt-style features
type, extends(forge_mainwindow) :: main_window
    ! Q_OBJECT  ! This would be processed by moc

    ! UI elements
    type(forge_button) :: click_button
    type(forge_label) :: status_label
    type(forge_checkbox) :: toggle_checkbox

    ! Signals
    type(signal_void) :: button_clicked_signal
    type(signal_string) :: status_changed_signal

    ! Slots
    type(slot_void_proc) :: on_button_clicked_proc
    type(slot_string_proc) :: on_status_changed_proc

contains
    procedure :: setup_ui
    procedure :: on_button_clicked
    procedure :: on_status_changed
end type main_window

subroutine setup_ui(this)
    class(main_window), intent(inout) :: this
    type(forge_layout) :: layout

    ! Initialize UI elements
    call this%click_button%init()
    call this%click_button%set_text("Click Me!")
    call this%click_button%set_object_name("clickButton")

    call this%status_label%init()
    call this%status_label%set_text("Ready")
    call this%status_label%set_object_name("statusLabel")

    call this%toggle_checkbox%init()
    call this%toggle_checkbox%set_text("Enable feature")
    call this%toggle_checkbox%set_object_name("toggleCheckbox")
 
    ! Setup layout
    call layout%init()
    call layout%add_widget(this%click_button)
    call layout%add_widget(this%status_label)
    call layout%add_widget(this%toggle_checkbox)
    call this%set_layout(layout)

    ! Connect signals and slots
    ! In real usage, these would be auto-generated by moc
    call this%button_clicked_signal%connect(this%on_button_clicked_proc)
    call this%status_changed_signal%connect(this%on_status_changed_proc)

    ! Connect button signal to slot
    call this%click_button%clicked%connect(this%on_button_clicked_proc)

end subroutine setup_ui

subroutine on_button_clicked(this)
    class(main_window), intent(inout) :: this

    ! Update status
    call this%status_label%set_text("Button clicked!")

    ! Emit custom signal
    call this%button_clicked_signal%emit()

end subroutine on_button_clicked

subroutine on_status_changed(this, new_status)
    class(main_window), intent(inout) :: this
    character(len=*), intent(in) :: new_status

    ! Handle status change
    write(*,*) "Status changed to: ", trim(new_status)

end subroutine on_status_changed
```

## Explanation

### Qt-Style Class Structure

```fortran
type, extends(forge_mainwindow) :: main_window
    ! Q_OBJECT  ! This would be processed by moc

    ! UI elements
    type(forge_button) :: click_button
    type(forge_label) :: status_label
    type(forge_checkbox) :: toggle_checkbox

    ! Signals
    type(signal_void) :: button_clicked_signal
    type(signal_string) :: status_changed_signal

    ! Slots
    type(slot_void_proc) :: on_button_clicked_proc
    type(slot_string_proc) :: on_status_changed_proc
```

The class structure mimics Qt:
- Extends a base window class
- Contains UI element members
- Defines signals and slots
- Uses `Q_OBJECT` macro (processed by moc)

### Application Initialization

```fortran
type(forge_application) :: app

! Initialize application
call app%init()
call app%set_application_name("Qt Demo")
call app%set_application_version("1.0.0")
```

Qt-style application setup with name and version.

### UI Setup

```fortran
subroutine setup_ui(this)
    class(main_window), intent(inout) :: this
    type(forge_layout) :: layout

    ! Initialize UI elements
    call this%click_button%init()
    call this%click_button%set_text("Click Me!")
    call this%click_button%set_object_name("clickButton")
```

UI setup follows Qt patterns:
- Initialize widgets
- Set properties
- Set object names for identification

### Signal/Slot Connections

```fortran
! Connect signals and slots
call this%button_clicked_signal%connect(this%on_button_clicked_proc)
call this%status_changed_signal%connect(this%on_status_changed_proc)

! Connect button signal to slot
call this%click_button%clicked%connect(this%on_button_clicked_proc)
```

Qt-style signal/slot connections for event handling.

### Qt Tools Integration

ForGE provides Qt-compatible tools:

#### UIC (UI Compiler)

```bash
# Compile .ui file to Fortran code
forge-uic mainwindow.ui -o ui_mainwindow.f90
```

#### MOC (Meta-Object Compiler)

```bash
# Generate meta-object code for signals/slots
forge-moc mainwindow.f90 -o moc_mainwindow.f90
```

#### RCC (Resource Compiler)

```bash
# Compile resources
forge-rcc resources.qrc -o qrc_resources.f90
```

#### LUPDATE/LRELEASE (Translation)

```bash
# Extract translatable strings
forge-lupdate mainwindow.f90 -ts translations/mainwindow_en.ts

# Compile translations
forge-lrelease translations/mainwindow_en.ts -qm translations/mainwindow_en.qm
```

## UI File Example

```xml
<!-- mainwindow.ui -->
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>600</width>
    <height>400</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>ForGE Qt Demo</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QVBoxLayout" name="verticalLayout">
    <item>
     <widget class="QPushButton" name="clickButton">
      <property name="text">
       <string>Click Me!</string>
      </property>
     </widget>
    </item>
    <item>
     <widget class="QLabel" name="statusLabel">
      <property name="text">
       <string>Ready</string>
      </property>
     </widget>
    </item>
    <item>
     <widget class="QCheckBox" name="toggleCheckbox">
      <property name="text">
       <string>Enable feature</string>
      </property>
     </widget>
    </item>
   </layout>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>
```

## Resource File Example

```xml
<!-- resources.qrc -->
<!DOCTYPE RCC>
<RCC version="1.0">
<qresource>
    <file>icons/app.png</file>
    <file>images/logo.png</file>
    <file>styles/dark.qss</file>
</qresource>
</RCC>
```

## Translation File Example

```xml
<!-- translations/mainwindow_en.ts -->
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE TS>
<TS version="2.1" language="en_US">
<context>
    <name>MainWindow</name>
    <message>
        <source>Click Me!</source>
        <translation>Click Me!</translation>
    </message>
    <message>
        <source>Ready</source>
        <translation>Ready</translation>
    </message>
    <message>
        <source>Enable feature</source>
        <translation>Enable feature</translation>
    </message>
</context>
</TS>
```

## Running the Example

### With fpm

```bash
fpm run qt_demo
```

### With CMake (Full Qt Toolchain)

```cmake
# CMakeLists.txt with Qt tools
find_package(ForGE REQUIRED)

# Generate code from UI files
forge_uic_generate(UI_HEADERS mainwindow.ui)
forge_moc_generate(MOC_SOURCES mainwindow.f90)
forge_rcc_generate(RCC_SOURCES resources.qrc)

add_executable(qt_demo
    qt_demo.f90
    ${UI_HEADERS}
    ${MOC_SOURCES}
    ${RCC_SOURCES}
)

target_link_libraries(qt_demo ForGE::forge_qt)
```

### Manual Build

```bash
# Generate Qt-compatible code
forge-uic mainwindow.ui -o ui_mainwindow.f90
forge-moc mainwindow.f90 -o moc_mainwindow.f90
forge-rcc resources.qrc -o qrc_resources.f90

# Compile
gfortran -I/path/to/forge/include \
         qt_demo.f90 \
         ui_mainwindow.f90 \
         moc_mainwindow.f90 \
         qrc_resources.f90 \
         -lforge_qt -o qt_demo
./qt_demo
```

## Key Concepts Demonstrated

1. **Qt-Style Classes**: QObject inheritance with signals/slots
2. **UI Compilation**: Converting .ui files to Fortran code
3. **Meta-Object System**: Runtime type information and introspection
4. **Resource Management**: Compiled resources in executable
5. **Internationalization**: Translation file support

## Qt Compatibility Features

### Signals and Slots

```fortran
! Define signals
type(signal_void) :: clicked
type(signal_string) :: text_changed

! Define slots
type(slot_void_proc) :: on_clicked
type(slot_string_proc) :: on_text_changed

! Connect
call clicked%connect(on_clicked)
call text_changed%connect(on_text_changed)

! Emit
call clicked%emit()
call text_changed%emit("new text")
```

### Properties

```fortran
! Qt-style properties (planned)
type :: my_widget
    integer :: width = 100
    character(len=:), allocatable :: text
contains
    ! Q_PROPERTY macros would generate getters/setters
end type my_widget
```

### Object Hierarchy

```fortran
! Qt-style object tree
type(forge_widget) :: parent
type(forge_widget) :: child1, child2

call parent%add_child(child1)
call parent%add_child(child2)

! Automatic cleanup when parent destroyed
```

## Advanced Qt Features

### Model/View Framework

```fortran
! Qt-style models (planned)
type :: string_list_model
    character(len=:), allocatable :: strings(:)
contains
    procedure :: row_count => string_list_model_row_count
    procedure :: data => string_list_model_data
end type string_list_model

type :: list_view
    class(abstract_item_model), pointer :: model => null()
contains
    procedure :: set_model => list_view_set_model
end type list_view
```

### Custom Widgets

```fortran
! Qt-style custom widgets
type, extends(forge_widget) :: custom_widget
    ! Q_OBJECT
    type(signal_paint) :: paint_signal
contains
    procedure :: paint_event => custom_widget_paint
end type custom_widget

subroutine custom_widget_paint(this, event)
    class(custom_widget), intent(inout) :: this
    type(paint_event), intent(in) :: event

    ! Custom painting code
    call this%qpainter%draw_rect(10, 10, 100, 50)
end subroutine custom_widget_paint
```

### Threading

```fortran
! Qt-style threading (planned)
type, extends(forge_object) :: worker
    ! Q_OBJECT
    type(signal_result) :: result_ready
contains
    procedure :: run => worker_run
end type worker

type :: worker_thread
    type(worker) :: worker_obj
contains
    procedure :: start => worker_thread_start
end type worker_thread
```

## Next Steps

- Read the [backend guide](../tutorials/backend_guide.md) for Qt backend details
- Learn about [signals and slots](../tutorials/signals_slots.md) in depth
- Explore [resource management](../tutorials/resources.md) for assets
- See the [calculator](../examples/calculator.md) for complex Qt-style applications